\documentclass[final, noposter]{polytech/polytech}

\schooldepartment{di}
\typereport{pldi5}
\reportyear{2018-2019}

\title{Création d'un calendrier de championat}
%\subtitle{}

\student{Thomas}{Couchoud}{thomas.couchoud@etu.univ-tours.fr}
\student{Victor}{Coleau}{victor.coleau@etu.univ-tours.fr}
\academicsupervisor{Christophe}{Lenté}{christophe.lente@univ-tours.fr}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%TODO
\resume{}
\motcle{}

\abstract{}
\keyword{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\chapter{Introduction}
	\section{Contexte}
	\section{Objectifs}
	\section{Hypothèses}

\chapter{Description générale}	
	\section{Environnement du projet}
	\section{Caractéristiques des utilisateurs}
		Les utilisateurs finaux du programme sont des gens n'ayant aucun lien avec l'informatique. De ce fait, le programme doit être utilisable de la manière la plus simple et intuitive possible. Pour cela il faut que l'utilisateur est le moins de paramètres à définir en amont à l'exception des fichiers d'entrée à fournir. De plus, il est nécessaire que l'interface graphique soit claire, propre et intuitive ainsi que simple de prise en main et d'utilisation.
 		
		Dans le cas où le développement serait par la suite continuer par une autre équipe, le projet fut conçu de sorte à être facilement reprit. Il suffit d'avoir un environnement de développement adapté (Voir \autoref{sec:maven}). De plus, la Javadoc est présente au sein du code afin de facilité sa prise en main.

	\section{Fonctionnalités du système}
		\subsection{Importer les données}
			La première chose que le programme doit faire est de lire un certain nombre de fichiers (2 dans le cas présent - un pour les gymnases et un pour les équipes) afin de pouvoir générer son modèle initial. Cette étape est nécessaire afin de le logiciel sache qu'elles données il aura à traiter par la suite.

			Les fichiers CSV d'entrée sont attendus sous la forme suivante (séparateur de colonne étant le point virgule) :

			\paragraph{Gymnases}
				Trois colonnes doivent être présentes : le nom du gymnase, sa capacité maximale et sa ville.
				
				\latexsourcefile[caption=Exemple de fichier CSV pour les gymnases]{../Planificateur/gyms.csv}

			\paragraph{Equipes}
				Quatre colonnes doivent être présentes : le nom de l'équipe, le nom du gymnase dans lequel jour l'équipe, la ville du gymnase et la poule à laquelle appartient l'équipe.
				
				\latexsourcefile[caption=Exemple de fichier CSV pour les équipes]{../Planificateur/teams.csv}

				Une importance particulière doit être portée sur les noms de poule puisque c'est à partir des valeurs de cette colonnes que seront définies les poules dans le modèle sous-jacent pour la suite des opération. La moindre erreur dans le nom du poule la différencierait des autres et en créerait donc une nouvelle.

		\subsection{Afficher le planning}

		\subsection{Planification des matches}

		\subsection{Exporter les résultats}

	\section{Description des interface}
	
\chapter{Réalisation du logiciel}
	Nous allons ici expliquer comment a été réalisé le programme afin de répondre à la problématique exposée précédemment.
	
	\section{Modèle}
		\img{classDiagram.png}{Diagramme de classe du model}{scale=0.5}
		
		La première étape a été de créer tout le modèle d'un championnat.
		Pour cela les classes dans le diagramme précédent ont été créées.
		
		Nous retrouvons tout en haut le Championship.
		Ce dernier représente tout le championnat et est donc composé de GroupStages, ainsi qu'un nombre de semaines sur lesquelles se déroule la compétition.
		
		Les GroupStage représentent les poules et ont chacune un nom ainsi qu'un liste de Match qui devront être joués.
		
		Les Match sont quand a eux composés de deux équipes (l'équipe qui va recevoir, et la deuxième) et d'une date.
		Si la date du match est encore inconnue la valeur << null >> lui serra assigné.
		
		Les équipes sont représentées par Team et comporte un nom ainsi que leur gymnase affecté.

		Enfin un Gymnase à une capacité, un nom, une liste de dates où le gymnase est indisponible et une couleur qui lui sera affecté dans l'interface.

	\section{Parser}
		
	
	\section{Interface}
		%TODO Thomas
	\section{Exportation}
		%TODO Thomas

\chapter{Gestion de projet}
	Afin de pouvoir travailler de manière efficace sur le peu de temps qui nous est alloué pour ce projet, nous avons mis quelques éléments de gestion de projet en place.
	Cela inclut par exemple du versionning de code et de l'intégration continue.
	
	\section{Maven\label{sec:maven}}
		Comme nous avons pu le voir précédemment notre code est développé en Java.
		Afin de réduire au maximum les étapes nécessaires à l'installation d'un environnement de développement pour le projet, nous avons décidé d'utilise Maven.
		
		Cet outil permet de gérer de manière uniformisé les processus de build, test, packaging ainsi que les dépendances.
		De cette manière il n'est pas nécessaire de télécharger manuellement des libraries à chaque fois ou bien être sûr que les même versions sont utilisées entre les différents environnements.
		Il suffit simplement de déclarer la librairie à utiliser ainsi que sa version.
		Maven se chargera lui même de récupérer la librairie adéquate.
		
		De plus toute la phase de build et test est déclaré auprès de maven ce qui permet d'avoir un code compilé de manière similaire peu importe l'environnement ou IDE utilisé.
		Cela est notamment pratique pour la partie intégration continue où le code est compilé sans IDE.
		
		Ainsi si le projet est repris par la suite, il suffit d'avoir un JDK version 11 ou plus, installer maven et coder.
		Les IDEs les plus connus supportent tous maven ce qui facilite encore plus la prise en main (il suffit d'ouvrir le pom.xml en tant que projet et ce dernier se configure automatiquement pour l'IDE utilisé).
	
		\img{Maven1.png}{Exemple de maven qui package notre application en un JAR exécutable multiplateformes}{scale=0.5}
		
	\section{Git}
		Un autre aspect qui a été utilisé tout au long du projet et le versionning de code.
		Ce système nous permet de gérer des "versions" de code de manière efficace en ayant un historique de tout le code ainsi que des outils pour fusionner plusieurs versions, effectuer des retours en arrière, etc.
		
	\section{Intégration continue} 
		Afin d'améliorer le développement, un système d'intégration continue a été mis en place.
	Cela permet d'effectuer certaines actions lorsqu'une modification sur le code est envoyé sur le serveur Git.
	Nous pouvons entre autres faire de la vérification de code grâce à une compilation et des tests.
	
	Voici les différentes étapes qui sont réalisées dans ce projet sont les suivantes:
	\img{ci-stages.png}{Etapes du CI}{}
	
	Afin de passer à une étape suivante, toutes les tâches de l'étape doivent être validées.
		
	\begin{easylist}[itemize]
		@ Etape build:
		@@ Effectue la compilation du projet
		@ Etape test:
		@@ Effectue les tests unitaires du projet
		@ Etape deploy:
		@@ build-jar: Construit un jar exécutable du projet
		@@ javadoc: Génère la Javadoc du projet
	\end{easylist}
	
	Si nous prenons l'exemple de la Javadoc, après la fin du job concerné, il est possible de télécharger cette dernière pour le code à cet instant t:
	\img{ci-artifacts.png}{Téléchargements des fichiers du job}{scale=1}
	
	De plus les tests unitaires produisent un résultat de test de couverture permettant ainsi de se rendre compte de l'efficacité de ces derniers. 
	\img{ci-coverage.png}{Pourcentage de couverture}{}
	
	Ces résultats sont aussi disponibles sur la page principale du projet sous forme de badges.
	\img{ci-badges.png}{Page principale du projet}{}
	
	La phase de déploiement permet de mettre en ligne la Javadoc ainsi qu'une version plus poussée su rapport de couverture des tests.
	\img{jacoco.png}{Rapport JaCoCo}{}

\chapter{Améliorations à prévoir}

\chapter{Conclusion}

\end{document}