\documentclass[final, noposter]{polytech/polytech}

\schooldepartment{di}
\typereport{pldi5}
\reportyear{2018-2019}

\title{Création d'un calendrier de championat}
%\subtitle{}

\student{Thomas}{Couchoud}{thomas.couchoud@etu.univ-tours.fr}
\student{Victor}{Coleau}{victor.coleau@etu.univ-tours.fr}
\academicsupervisor{Christophe}{Lenté}{christophe.lente@univ-tours.fr}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%TODO
\resume{}
\motcle{}

\abstract{}
\keyword{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\chapter{Introduction}
	\section{Contexte}
		Dans le cadre de championnats sportifs, les organisateurs sont souvent amenés à planifier les rencontres entre équipes. Ce travail peut être plus ou moins complexe en fonction du nombre d'équipes à gérer, du nombre de poules dans le championnat, des contraintes de lieux (chaque équipe ayant un gymnase à domicile), de dates (une équipe ne doit pas jouer tous ses matchs d'affilée), d'alternance (une équipe ne doit pas jouer tous ses matchs en extérieur d'affilée), etc.
		
		De plus, ces rencontres sont souvent sous forme de match aller-retour. La période aller devant précéder celle de retour.
		
		Tout cela créé un environnement complexe à appréhender, où l'ensemble des contraintes devient vite bloquant.

	\section{Objectifs}
		L'objectif de ce projet libre est donc de proposer un logiciel graphique facilitant la planification après import des données au sein du système.
		
		Celui-ci aura deux buts principaux : 
		\begin{easylist}[itemize]
			@ La partie graphique servira à représenter de manière simple un calendrier de matchs afin qu'un utilisateur humain puisse, d'un simple coup d'oeil, voir et comprendre l'état actuel de la planification.
			@ Le logiciel devra intégrer un certain nombre de contraintes prédéfinies, plus ou moins bloquantes, telles que le fait qu'un équipe ne peut pas jouer deux fois la même semaine. Cela a aussi pour but d'aider l'utilisateur dans la prise en compte des contraintes.
		\end{easylist}

	\section{Hypothèses}
		Pour la réalisation de ce calendrier interactif, plusieurs hypothèses relatives au monde sportif ont été posées :
		\begin{easylist}[itemize]
			@ Un championnat se compose de plusieurs poules regroupant les équipes. Ces poules ne sont pas strictement indépendantes puisse que certaines contraintes peuvent être communes.
			@ Au sein d'un poule, toutes les équipes doivent rencontrer toutes les autres deux fois. Le premier match devra se dérouler dans le gymnase de la première équipe, et le second dans le gymnase de la deuxième équipe.
			@ Chaque équipe est associé à un gymnase de référence. Ce gymnase est celui dans lequel l'équipe joue son match à domicile. Un gymnase possède une capacité maximale de matchs en simultané. Plusieurs équipes peuvent être associées au même gymnase. Dans le cas où les équipes seraient dans des poules différentes, il faudra donc faire attention à ne pas dépasser la capacité du gymnase.
		\end{easylist}

\chapter{Description générale}	
	\section{Environnement du projet}
		Lors de la réalisation de notre projet, aucun existant n’est déjà présent. Nous voulons mettre à disposition de l’utilisateur une application simple, intuitive et facile d'utilisation.
		
		Nous avons donc choisi de mettre en place l’environnement suivant :
		\img{InteractionSchema.png}{Architecture générale du projet}{}

		Comme on peut le voir sur la figure précédente, l'application comportera est partie interface graphique avec laquelle l'utilisateur interagira et une partie algorithmique, régissant les contraintes pré-établies.
		
		De plus, le programme prendra en entrée des fichiers au format CSV contenant les informations nécessaires et permettra d'exporter le résultat de la planification dans un fichier CSV.

		Le développement de l'application se fait en Java. De ce fait, nous utilisons la librairie JavaFX pour l'affichage graphique.
		
		Afin de pouvoir utiliser l'application il est donc nécessaire d'avoir Java 12 ou supérieur d'installé sur l'ordinateur.
		
		Ce dernier peut être téléchargée ici: \href{https://jdk.java.net/}{OpenJDK downloads} (ou ici pour la version Oracle: \href{https://www.oracle.com/technetwork/java/javase/downloads/index.html}{Oracle downloads})(\href{https://adoptopenjdk.net/}{une version d'OpenJDK est distribuée par AdoptOpenJDK} et propose un installateur afin de faciliter l'installation de Java).
		
	    Il suffit de prendre la version adaptée à l'architecture cible et suivre les étapes d'installation (peut différer selon vos besoins, néanmoins une possibilité est expliquée \href{https://stackoverflow.com/a/52531093/3281185}{ici}).

	\section{Caractéristiques des utilisateurs}
		Les utilisateurs finaux du programme sont des gens n'ayant aucun lien avec l'informatique. De ce fait, le programme doit être utilisable de la manière la plus simple et intuitive possible. Pour cela il faut que l'utilisateur est le moins de paramètres à définir en amont à l'exception des fichiers d'entrée à fournir. De plus, il est nécessaire que l'interface graphique soit claire, propre et intuitive ainsi que simple de prise en main et d'utilisation.
 		
		Dans le cas où le développement serait par la suite continuer par une autre équipe, le projet fut conçu de sorte à être facilement reprit. Il suffit d'avoir un environnement de développement adapté (Voir \autoref{sec:maven}). De plus, la Javadoc est présente au sein du code afin de facilité sa prise en main.

	\section{Fonctionnalités du système}
		\subsection{Importer les données}
			La première chose que le programme doit faire est de lire un certain nombre de fichiers (2 dans le cas présent - un pour les gymnases et un pour les équipes) afin de pouvoir générer son modèle initial. Cette étape est nécessaire afin de le logiciel sache qu'elles données il aura à traiter par la suite.

			Les fichiers CSV d'entrée sont attendus sous la forme suivante (séparateur de colonne étant le point virgule) :

			\paragraph{Gymnases}
				Trois colonnes doivent être présentes : le nom du gymnase, sa capacité maximale et sa ville.
				
				\latexsourcefile[label=code:gyms,caption=Exemple de fichier CSV pour les gymnases]{../Planificateur/gyms.csv}

			\paragraph{Equipes}
				Quatre colonnes doivent être présentes : le nom de l'équipe, le nom du gymnase dans lequel jour l'équipe, la ville du gymnase et la poule à laquelle appartient l'équipe.
				
				\latexsourcefile[label=code:teams,caption=Exemple de fichier CSV pour les équipes]{../Planificateur/teams.csv}

				Une importance particulière doit être portée sur les noms de poule puisque c'est à partir des valeurs de cette colonnes que seront définies les poules dans le modèle sous-jacent pour la suite des opération. La moindre erreur dans le nom du poule la différencierait des autres et en créerait donc une nouvelle.

		\subsection{Afficher le planning}

		\subsection{Planification des matches}

		\subsection{Exporter les résultats}

	\section{Description des interface}
	
\chapter{Réalisation du logiciel}
	Nous allons ici expliquer comment a été réalisé le programme afin de répondre à la problématique exposée précédemment.
	
	\section{Modèle}
		\img{classDiagram.png}{Diagramme de classe du model}{scale=0.5}
		
		La première étape a été de créer tout le modèle d'un championnat.
		Pour cela les classes dans le diagramme précédent ont été créées.
		
		Nous retrouvons tout en haut le Championship.
		Ce dernier représente tout le championnat et est donc composé de GroupStages, ainsi qu'un nombre de semaines sur lesquelles se déroule la compétition.
		
		Les GroupStage représentent les poules et ont chacune un nom ainsi qu'un liste de Match qui devront être joués.
		
		Les Match sont quand a eux composés de deux équipes (l'équipe qui va recevoir, et la deuxième) et d'une date.
		Si la date du match est encore inconnue la valeur << null >> lui serra assigné.
		
		Les équipes sont représentées par Team et comporte un nom ainsi que leur gymnase affecté.

		Enfin un Gymnase à une capacité, un nom, une liste de dates où le gymnase est indisponible et une couleur qui lui sera affecté dans l'interface.

	\section{Parser}
		Etant donné que les données du championnat se trouve à l'origine dans des fichiers Excel, il est nécessaire de réaliser un parseur qui va traduire les différentes données dans le modèle de notre programme.
		Excel étant propriétaire, nous avons préféré nous focaliser sur un format plus large, le CSV (excel est capable d'exporter un document dans ce format).
		
		Des exemples de fichiers ont été donnés en \autoref{code:teams} et \autoref{code:gyms}.
		A partir de là, chaque ligne représente un gymnase ou bien une équipe.
		Il suffit donc de simplement récupérer chaque information et créer les instances du modèle associé.
		
		Ce qui manque est la liste des différents matchs qui devront être joués.
		Pour cela nous créons un match entre toutes les paires d'équipes possible.
		Nous considérons que l'<< équipe 1 >> de la paire représente l'équipe accueillante.
	
	\section{Interface}
		%TODO Thomas
	\section{Exportation}
		%TODO Thomas

\chapter{Gestion de projet}
	Afin de pouvoir travailler de manière efficace sur le peu de temps qui nous est alloué pour ce projet, nous avons mis quelques éléments de gestion de projet en place.
	Cela inclut par exemple du versionning de code et de l'intégration continue.
	
	\section{Maven\label{sec:maven}}
		Comme nous avons pu le voir précédemment notre code est développé en Java.
		Afin de réduire au maximum les étapes nécessaires à l'installation d'un environnement de développement pour le projet, nous avons décidé d'utilise Maven.
		
		Cet outil permet de gérer de manière uniformisé les processus de build, test, packaging ainsi que les dépendances.
		De cette manière il n'est pas nécessaire de télécharger manuellement des libraries à chaque fois ou bien être sûr que les même versions sont utilisées entre les différents environnements.
		Il suffit simplement de déclarer la librairie à utiliser ainsi que sa version.
		Maven se chargera lui même de récupérer la librairie adéquate.
		
		De plus toute la phase de build et test est déclaré auprès de maven ce qui permet d'avoir un code compilé de manière similaire peu importe l'environnement ou IDE utilisé.
		Cela est notamment pratique pour la partie intégration continue où le code est compilé sans IDE.
		
		Ainsi si le projet est repris par la suite, il suffit d'avoir un JDK version 11 ou plus, installer maven et coder.
		Les IDEs les plus connus supportent tous maven ce qui facilite encore plus la prise en main (il suffit d'ouvrir le pom.xml en tant que projet et ce dernier se configure automatiquement pour l'IDE utilisé).
	
		\img{Maven1.png}{Exemple de maven qui package notre application en un JAR exécutable multiplateformes}{scale=0.5}
		
	\section{Git}
		Un autre aspect qui a été utilisé tout au long du projet et le versionning de code.
		Ce système nous permet de gérer des "versions" de code de manière efficace en ayant un historique de tout le code ainsi que des outils pour fusionner plusieurs versions, effectuer des retours en arrière, etc.
		
	\section{Intégration continue} 
		Afin d'améliorer le développement, un système d'intégration continue a été mis en place.
	Cela permet d'effectuer certaines actions lorsqu'une modification sur le code est envoyé sur le serveur Git.
	Nous pouvons entre autres faire de la vérification de code grâce à une compilation et des tests.
	
	Voici les différentes étapes qui sont réalisées dans ce projet sont les suivantes:
	\img{ci-stages.png}{Etapes du CI}{}
	
	Afin de passer à une étape suivante, toutes les tâches de l'étape doivent être validées.
		
	\begin{easylist}[itemize]
		@ Etape build:
		@@ Effectue la compilation du projet
		@ Etape test:
		@@ Effectue les tests unitaires du projet
		@ Etape deploy:
		@@ build-jar: Construit un jar exécutable du projet
		@@ javadoc: Génère la Javadoc du projet
	\end{easylist}
	
	Si nous prenons l'exemple de la Javadoc, après la fin du job concerné, il est possible de télécharger cette dernière pour le code à cet instant t:
	\img{ci-artifacts.png}{Téléchargements des fichiers du job}{scale=1}
	
	De plus les tests unitaires produisent un résultat de test de couverture permettant ainsi de se rendre compte de l'efficacité de ces derniers. 
	\img{ci-coverage.png}{Pourcentage de couverture}{}
	
	Ces résultats sont aussi disponibles sur la page principale du projet sous forme de badges.
	\img{ci-badges.png}{Page principale du projet}{}
	
	La phase de déploiement permet de mettre en ligne la Javadoc ainsi qu'une version plus poussée su rapport de couverture des tests.
	\img{jacoco.png}{Rapport JaCoCo}{}

\chapter{Améliorations à prévoir}

\chapter{Conclusion}

\end{document}